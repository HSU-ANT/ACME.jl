<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · ACME.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ACME.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="gettingstarted.html">Getting Started</a></li><li class="current"><a class="toctext" href="ug.html">User Guide</a><ul class="internal"><li><a class="toctext" href="#Element-Creation-1">Element Creation</a></li><li><a class="toctext" href="#Circuit-Description-1">Circuit Description</a></li><li><a class="toctext" href="#Model-Creation-and-Use-1">Model Creation and Use</a></li><li><a class="toctext" href="#Solvers-1">Solvers</a></li></ul></li><li><a class="toctext" href="elements.html">Element Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="ug.html">User Guide</a></li></ul><a class="edit-page" href="https://github.com/HSU-ANT/ACME.jl/blob/master/docs/src/ug.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><h2><a class="nav-anchor" id="Element-Creation-1" href="#Element-Creation-1">Element Creation</a></h2><p>All circuit elements are created by calling corresponding functions; see the <a href="elements.html#Element-Reference-1">Element Reference</a> for details.</p><h2><a class="nav-anchor" id="Circuit-Description-1" href="#Circuit-Description-1">Circuit Description</a></h2><p>Circuits are described using <code>Circuit</code> instances, which are most easily created using the <code>@circuit</code> macro:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.@circuit" href="#ACME.@circuit"><code>ACME.@circuit</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@circuit begin #= ... =# end</code></pre><p>Provides a simple domain-specific language to decribe circuits. The <code>begin</code>/<code>end</code> block can hold element definitions of the form <code>refdes = elementfunc(params)</code> and connection specifications of the form <code>refdes1[pin1] ⟷ refdes2[pin2]</code>.</p><p><strong>Example</strong></p><p>To create a circuit with a voltage source connected to a resistor:</p><pre><code class="language-julia">@circuit begin
    src = voltagesource(5)
    r = resistor(1000)
    src[+] ⟷ r[1]
    src[-] ⟷ r[2]
end</code></pre><p>Alternatively, connection specifications can be given after an element specification, separated by commas. In that case, the <code>refdes</code> may be omitted, defaulting to the current element.</p><p><strong>Example</strong></p><pre><code class="language-julia">@circuit begin
    src = voltagesource(5)
    r = resistor(1000), src[+] ⟷ [1], src[-] ⟷ [2]
end</code></pre><p>Finally, a connection endpoint may simply be of the form <code>netname</code>, to connect to a named net. (Such named nets are created as needed.)</p><p><strong>Example</strong></p><pre><code class="language-julia">@circuit begin
    src = voltagesource(5), [-] ⟷ gnd
    r = resistor(1000), [1] ⟷ src[+], [2] ⟷ gnd
end</code></pre><p>If a net or pin specification is not just a single symbol or number, and has to be put in quotes (e.g. <code>&quot;in+&quot;</code>, <code>&quot;9V&quot;</code>)</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Instead of <code>⟷</code> (<code>\\longleftrightarrow</code>), one can also use <code>==</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/circuit.jl#L304">source</a></section><p>The pins provided by each type of element are described in the <a href="elements.html#Element-Reference-1">Element Reference</a>.</p><p>Instead of or in addition to using the <code>@circuit</code> macro, <code>Circuit</code> instances can also be populated and modified programmatically using the following functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.add!" href="#ACME.add!"><code>ACME.add!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">add!(c::Circuit, elem::Element)</code></pre><p>Adds the element <code>elem</code> to the circuit <code>c</code>, creating and returning a new, unique reference designator, leaving its pins unconnected.</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/circuit.jl#L103-L108">source</a><div><div><pre><code class="language-none">add!(c::Circuit, designator::Symbol, elem::Element)</code></pre><p>Adds the element <code>elem</code> to the circuit <code>c</code> with the reference designator <code>designator</code>, leaving its pins unconnected. If the circuit already contained an element named <code>designator</code>, it is removed first.</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/circuit.jl#L122-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">delete!(c::Circuit, designator::Symbol)</code></pre><p>Deletes the element named <code>designator</code> from the circuit <code>c</code> (disconnecting all its pins).</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/circuit.jl#L139-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.connect!" href="#ACME.connect!"><code>ACME.connect!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connect!(c::Circuit, pins::Union{Symbol,Tuple{Symbol,Any}}...)</code></pre><p>Connects the given pins (or named nets) to each other in the circuit <code>c</code>. Named nets are given as <code>Symbol</code>s, pins are given as <code>Tuple{Symbols,Any}</code>s, where the first entry is the reference designator of an element in <code>c</code>, and the second entry is the pin name. For convenience, the latter is automatically converted to a <code>Symbol</code> as needed.</p><p><strong>Example</strong></p><pre><code class="language-julia">circ = Circuit()
add!(circ, :r, resistor(1e3))
add!(circ, :src, voltagesource(5))
connect!(circ, (:src, -), (:r, 2), :gnd) # connect to gnd net</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/circuit.jl#L188-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.disconnect!" href="#ACME.disconnect!"><code>ACME.disconnect!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disconnect!(c::Circuit, p::Tuple{Symbol,Any})</code></pre><p>Disconnects the given pin <code>p</code> from anything else in the circuit <code>c</code>. The pin is given as a<code>Tuple{Symbols,Any}</code>, where the first entry is the reference designator of an element in <code>c</code>, and the second entry is the pin name. For convenience, the latter is automatically converted to a <code>Symbol</code> as needed. Note that if e.g. three pin <code>p1</code>, <code>p2</code>, and <code>p3</code> are connected then <code>disconnect!(c, p1)</code> will disconnect <code>p1</code> from <code>p2</code> and <code>p3</code>, but leave <code>p2</code> and <code>p3</code> connected to each other.</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/circuit.jl#L227-L237">source</a></section><p>For example, a cascade of 20 RC-lowpasses could be generated by:</p><pre><code class="language-julia">circ = @circuit begin
    src = voltagesource(), [-] ⟷ gnd
    output = voltageprobe(), [-] ⟷ gnd
end
pin = (:src, +)
for i in 1:20
    resrefdes = add!(circ, resistor(1000))
    caprefdes = add!(circ, capacitor(10e-9))
    connect!(circ, (resrefdes, 1), pin)
    connect!(circ, (resrefdes, 2), (caprefdes, 1))
    connect!(circ, (caprefdes, 2), :gnd)
    global pin = (resrefdes, 2)
end
connect!(circ, pin, (:output, +))</code></pre><h2><a class="nav-anchor" id="Model-Creation-and-Use-1" href="#Model-Creation-and-Use-1">Model Creation and Use</a></h2><p>A <code>Circuit</code> only stores elements and information about their connections. To simulate a circuit, a model has to be derived from it. This can be as simple as:</p><pre><code class="language-julia">model = DiscreteModel(circ, 1/44100)</code></pre><p>Here, <code>1/44100</code> denotes the sampling interval, i.e. the reciprocal of the sampling rate at which the model should run. Optionally, one can specify the solver to use for solving the model&#39;s non-linear equation:</p><pre><code class="language-julia">model = DiscreteModel(circ, 1/44100, HomotopySolver{SimpleSolver})</code></pre><p>See <a href="ug.html#Solvers-1">Solvers</a> for more information about the available solvers.</p><p>Once a model is created, it can be run:</p><pre><code class="language-julia">y = run!(model, u)</code></pre><p>The input <code>u</code> is matrix with one row for each of the circuit&#39;s inputs and one column for each time step to simulate. Likewise, the output <code>y</code> will be a matrix with one row for each of the circuit&#39;s outputs and one column for each simulated time step. The order of the rows will correspond to the order in which the respective input and output elements were added to the <code>Circuit</code>. So for above circuit, we may obtain the first 100 samples of the impulse response with</p><pre><code class="language-julia">run!(model, [1 zeros(1,99)])

# output

1×100 Array{Float64,2}:
 1.83357e-8  3.1622e-7  2.59861e-6  …  0.00465423  0.00459275  0.00453208</code></pre><p>To simulate a circuit without inputs, a matrix with zero rows may be passed:</p><pre><code class="language-julia">y = run!(model, zeros(0, 100))</code></pre><p>The internal state of the model (e.g. capacitor charges) is preserved accross calls to <code>run!</code>.</p><p>Each invocation of <code>run!</code> in this way has to allocate some memory as temporary storage. To avoid this overhead when running the same model for many small input blocks, a <code>ModelRunner</code> instance can be created explicitly:</p><pre><code class="language-julia">runner = ModelRunner(model, false)
run!(runner, y, u)</code></pre><p>By using a pre-allocated output <code>y</code> as in the example, allocations in <code>run!</code> are reduced to a minimum.</p><p>Upon creation of a <code>DiscreteModel</code>, its internal states (e.g. capacitor charges) are set to zero. It is also possible to set the states to a steady state (if one can be found) with:</p><pre><code class="language-julia">steadystate!(model)</code></pre><p>This is often desirable for circuits where bias voltages are only slowly obtained after turning them on.</p><h2><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.SimpleSolver" href="#ACME.SimpleSolver"><code>ACME.SimpleSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SimpleSolver</code></pre><p>The <code>SimpleSolver</code> is the simplest available solver. It uses Newton iteration which features fast local convergence, but makes no guarantees about global convergence. The initial solution of the iteration is obtained by extrapolating the last solution found (or another solution provided externally) using the available Jacobians. Due to the missing global convergence, the <code>SimpleSolver</code> is rarely useful as such.</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/solvers.jl#L140-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.HomotopySolver" href="#ACME.HomotopySolver"><code>ACME.HomotopySolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HomotopySolver{BaseSolver}</code></pre><p>The <code>HomotopySolver</code> extends an existing solver (provided as the type parameter) by applying homotopy to (at least theoretically) ensure global convergence. It can be combined with the <code>SimpleSolver</code> as <code>HomotopySolver{SimpleSolver}</code> to obtain a useful Newton homtopy solver with generally good convergence properties.</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/solvers.jl#L237-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ACME.CachingSolver" href="#ACME.CachingSolver"><code>ACME.CachingSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CachingSolver{BaseSolver}</code></pre><p>The <code>CachingSolver</code> extends an existing solver (provided as the type parameter) by storing found solutions in a k-d tree to use as initial solutions in the future. Whenever the underlying solver needs more than a preset number of iterations (defaults to five), the solution will be stored. Storing new solutions is a relatively expensive operation, so until the stored solutions suffice to ensure convergence in few iterations throughout, use of a <code>CachingSolver</code> may actually slow things down.</p><p>See <a href="http://www.eurasip.org/Proceedings/Eusipco/Eusipco2016/papers/1570255150.pdf">M. Holters, U. Zölzer, &quot;A k-d Tree Based Solution Cache for the Non-linear Equation of Circuit Simulations&quot;</a> for a more detailed discussion.</p></div></div><a class="source-link" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/dd5988b925ccb45814526f2c3daa407734eb96ca/src/solvers.jl#L303-L317">source</a></section><p>The default solver used is a <code>HomotopySolver{CachingSolver{SimpleSolver}}</code>.</p><footer><hr/><a class="previous" href="gettingstarted.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="elements.html"><span class="direction">Next</span><span class="title">Element Reference</span></a></footer></article></body></html>
