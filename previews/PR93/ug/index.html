<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · ACME.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ACME.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Element-Creation"><span>Element Creation</span></a></li><li><a class="tocitem" href="#Circuit-Description"><span>Circuit Description</span></a></li><li><a class="tocitem" href="#Model-Creation-and-Use"><span>Model Creation and Use</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li></ul></li><li><a class="tocitem" href="../elements/">Element Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/HSU-ANT/ACME.jl/blob/master/docs/src/ug.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Guide"><a class="docs-heading-anchor" href="#User-Guide">User Guide</a><a id="User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-Guide" title="Permalink"></a></h1><h2 id="Element-Creation"><a class="docs-heading-anchor" href="#Element-Creation">Element Creation</a><a id="Element-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Element-Creation" title="Permalink"></a></h2><p>All circuit elements are created by calling corresponding functions; see the <a href="../elements/#Element-Reference">Element Reference</a> for details.</p><h3 id="Unitful-elements"><a class="docs-heading-anchor" href="#Unitful-elements">Unitful elements</a><a id="Unitful-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Unitful-elements" title="Permalink"></a></h3><p>ACME provides a package extension for <a href="https://github.com/PainterQubits/Unitful.jl">Unitful</a> to support quantities with units when constructing elements. E.g. <code>resistor(4.7e3)</code> and <code>resistor(4.7u&quot;kΩ&quot;)</code> are equivalent after <code>Unitful</code> has been loaded. This can increase readability and help catch bugs (e.g. <code>resistor(5u&quot;V&quot;)</code> will throw an error). The input and output signals of the curcuit models will still be unitless, however.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p>Package extensions require Julia 1.9 or later. Consequently, unitful quantities are not supported on earlier Julia versions.</p></div></div><h2 id="Circuit-Description"><a class="docs-heading-anchor" href="#Circuit-Description">Circuit Description</a><a id="Circuit-Description-1"></a><a class="docs-heading-anchor-permalink" href="#Circuit-Description" title="Permalink"></a></h2><p>Circuits are described using <code>Circuit</code> instances, which are most easily created using the <code>@circuit</code> macro:</p><article class="docstring"><header><a class="docstring-binding" id="ACME.@circuit" href="#ACME.@circuit"><code>ACME.@circuit</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@circuit begin #= ... =# end</code></pre><p>Provides a simple domain-specific language to decribe circuits. The <code>begin</code>/<code>end</code> block can hold element definitions of the form <code>refdes = elementfunc(params)</code> and connection specifications of the form <code>refdes1[pin1] ⟷ refdes2[pin2]</code>.</p><p><strong>Example</strong></p><p>To create a circuit with a voltage source connected to a resistor:</p><pre><code class="language-julia hljs">@circuit begin
    src = voltagesource(5)
    r = resistor(1000)
    src[+] ⟷ r[1]
    src[-] ⟷ r[2]
end</code></pre><p>Alternatively, connection specifications can be given after an element specification, separated by commas. In that case, the <code>refdes</code> may be omitted, defaulting to the current element.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@circuit begin
    src = voltagesource(5)
    r = resistor(1000), src[+] ⟷ [1], src[-] ⟷ [2]
end</code></pre><p>Finally, a connection endpoint may simply be of the form <code>netname</code>, to connect to a named net. (Such named nets are created as needed.)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@circuit begin
    src = voltagesource(5), [-] ⟷ gnd
    r = resistor(1000), [1] ⟷ src[+], [2] ⟷ gnd
end</code></pre><p>If a net or pin specification is not just a single symbol or number, and has to be put in quotes (e.g. <code>&quot;in+&quot;</code>, <code>&quot;9V&quot;</code>)</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Instead of <code>⟷</code> (<code>\longleftrightarrow</code>), one can also use <code>==</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/circuit.jl#L254-L316">source</a></section></article><p>The pins provided by each type of element are described in the <a href="../elements/#Element-Reference">Element Reference</a>.</p><p>Instead of or in addition to using the <code>@circuit</code> macro, <code>Circuit</code> instances can also be populated and modified programmatically using the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="ACME.add!" href="#ACME.add!"><code>ACME.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add!(c::Circuit, elem::Element)</code></pre><p>Adds the element <code>elem</code> to the circuit <code>c</code>, creating and returning a new, unique reference designator, leaving its pins unconnected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/circuit.jl#L88-L93">source</a></section><section><div><pre><code class="nohighlight hljs">add!(c::Circuit, designator::Symbol, elem::Element)</code></pre><p>Adds the element <code>elem</code> to the circuit <code>c</code> with the reference designator <code>designator</code>, leaving its pins unconnected. If the circuit already contained an element named <code>designator</code>, it is removed first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/circuit.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">delete!(c::Circuit, designator::Symbol)</code></pre><p>Deletes the element named <code>designator</code> from the circuit <code>c</code> (disconnecting all its pins).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/circuit.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACME.connect!" href="#ACME.connect!"><code>ACME.connect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">connect!(c::Circuit, pins::Union{Symbol,Tuple{Symbol,Any}}...)</code></pre><p>Connects the given pins (or named nets) to each other in the circuit <code>c</code>. Named nets are given as <code>Symbol</code>s, pins are given as <code>Tuple{Symbols,Any}</code>s, where the first entry is the reference designator of an element in <code>c</code>, and the second entry is the pin name. For convenience, the latter is automatically converted to a <code>Symbol</code> as needed.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">circ = Circuit()
add!(circ, :r, resistor(1e3))
add!(circ, :src, voltagesource(5))
connect!(circ, (:src, -), (:r, 2), :gnd) # connect to gnd net</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/circuit.jl#L154-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACME.disconnect!" href="#ACME.disconnect!"><code>ACME.disconnect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disconnect!(c::Circuit, p::Tuple{Symbol,Any})</code></pre><p>Disconnects the given pin <code>p</code> from anything else in the circuit <code>c</code>. The pin is given as a<code>Tuple{Symbols,Any}</code>, where the first entry is the reference designator of an element in <code>c</code>, and the second entry is the pin name. For convenience, the latter is automatically converted to a <code>Symbol</code> as needed. Note that if e.g. three pin <code>p1</code>, <code>p2</code>, and <code>p3</code> are connected then <code>disconnect!(c, p1)</code> will disconnect <code>p1</code> from <code>p2</code> and <code>p3</code>, but leave <code>p2</code> and <code>p3</code> connected to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/circuit.jl#L195-L205">source</a></section></article><p>For example, a cascade of 20 RC-lowpasses could be generated by:</p><pre><code class="language-julia hljs">circ = @circuit begin
    src = voltagesource(), [-] ⟷ gnd
    output = voltageprobe(), [-] ⟷ gnd
end
pin = (:src, +)
for i in 1:20
    resrefdes = add!(circ, resistor(1000))
    caprefdes = add!(circ, capacitor(10e-9))
    connect!(circ, (resrefdes, 1), pin)
    connect!(circ, (resrefdes, 2), (caprefdes, 1))
    connect!(circ, (caprefdes, 2), :gnd)
    global pin = (resrefdes, 2)
end
connect!(circ, pin, (:output, +))</code></pre><h2 id="Model-Creation-and-Use"><a class="docs-heading-anchor" href="#Model-Creation-and-Use">Model Creation and Use</a><a id="Model-Creation-and-Use-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Creation-and-Use" title="Permalink"></a></h2><p>A <code>Circuit</code> only stores elements and information about their connections. To simulate a circuit, a model has to be derived from it. This can be as simple as:</p><pre><code class="language-julia hljs">model = DiscreteModel(circ, 1/44100)</code></pre><p>Here, <code>1/44100</code> denotes the sampling interval, i.e. the reciprocal of the sampling rate at which the model should run. Optionally, one can specify the solver to use for solving the model&#39;s non-linear equation:</p><pre><code class="language-julia hljs">model = DiscreteModel(circ, 1/44100, HomotopySolver{SimpleSolver})</code></pre><p>See <a href="#Solvers">Solvers</a> for more information about the available solvers.</p><p>Once a model is created, it can be run:</p><pre><code class="language-julia hljs">y = run!(model, u)</code></pre><p>The input <code>u</code> is matrix with one row for each of the circuit&#39;s inputs and one column for each time step to simulate. Likewise, the output <code>y</code> will be a matrix with one row for each of the circuit&#39;s outputs and one column for each simulated time step. The order of the rows will correspond to the order in which the respective input and output elements were added to the <code>Circuit</code>. So for above circuit, we may obtain the first 100 samples of the impulse response with</p><pre><code class="language-julia hljs">run!(model, [1 zeros(1,99)])

# output

1×100 Matrix{Float64}:
 1.83357e-8  3.1622e-7  2.59861e-6  …  0.00465423  0.00459275  0.00453208</code></pre><p>To simulate a circuit without inputs, a matrix with zero rows may be passed:</p><pre><code class="language-julia hljs">y = run!(model, zeros(0, 100))</code></pre><p>The internal state of the model (e.g. capacitor charges) is preserved accross calls to <code>run!</code>.</p><p>Each invocation of <code>run!</code> in this way has to allocate some memory as temporary storage. To avoid this overhead when running the same model for many small input blocks, a <code>ModelRunner</code> instance can be created explicitly:</p><pre><code class="language-julia hljs">runner = ModelRunner(model, false)
run!(runner, y, u)</code></pre><p>By using a pre-allocated output <code>y</code> as in the example, allocations in <code>run!</code> are reduced to a minimum.</p><p>Upon creation of a <code>DiscreteModel</code>, its internal states (e.g. capacitor charges) are set to zero. It is also possible to set the states to a steady state (if one can be found) with:</p><pre><code class="language-julia hljs">steadystate!(model)</code></pre><p>This is often desirable for circuits where bias voltages are only slowly obtained after turning them on.</p><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ACME.SimpleSolver" href="#ACME.SimpleSolver"><code>ACME.SimpleSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleSolver</code></pre><p>The <code>SimpleSolver</code> is the simplest available solver. It uses Newton iteration which features fast local convergence, but makes no guarantees about global convergence. The initial solution of the iteration is obtained by extrapolating the last solution found (or another solution provided externally) using the available Jacobians. Due to the missing global convergence, the <code>SimpleSolver</code> is rarely useful as such.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/solvers.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACME.HomotopySolver" href="#ACME.HomotopySolver"><code>ACME.HomotopySolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HomotopySolver{BaseSolver}</code></pre><p>The <code>HomotopySolver</code> extends an existing solver (provided as the type parameter) by applying homotopy to (at least theoretically) ensure global convergence. It can be combined with the <code>SimpleSolver</code> as <code>HomotopySolver{SimpleSolver}</code> to obtain a useful Newton homtopy solver with generally good convergence properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/solvers.jl#L238-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ACME.CachingSolver" href="#ACME.CachingSolver"><code>ACME.CachingSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachingSolver{BaseSolver}</code></pre><p>The <code>CachingSolver</code> extends an existing solver (provided as the type parameter) by storing found solutions in a k-d tree to use as initial solutions in the future. Whenever the underlying solver needs more than a preset number of iterations (defaults to five), the solution will be stored. Storing new solutions is a relatively expensive operation, so until the stored solutions suffice to ensure convergence in few iterations throughout, use of a <code>CachingSolver</code> may actually slow things down.</p><p>See <a href="http://www.eurasip.org/Proceedings/Eusipco/Eusipco2016/papers/1570255150.pdf">M. Holters, U. Zölzer, &quot;A k-d Tree Based Solution Cache for the Non-linear Equation of Circuit Simulations&quot;</a> for a more detailed discussion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/HSU-ANT/ACME.jl/blob/7fcdef54794857f00d3139086b887870d41d1ffa/src/solvers.jl#L304-L318">source</a></section></article><p>The default solver used is a <code>HomotopySolver{CachingSolver{SimpleSolver}}</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gettingstarted/">« Getting Started</a><a class="docs-footer-nextpage" href="../elements/">Element Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 25 January 2023 14:41">Wednesday 25 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
