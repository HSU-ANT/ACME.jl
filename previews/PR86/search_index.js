var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If you have not done so already, download and install Julia. (Any version starting with 1.4 should be fine; earlier ACME versions also support Julia 0.3 and later.)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To install ACME, start Julia and run:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Pkg.add(\"ACME\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"This will download ACME and all of its dependencies.","category":"page"},{"location":"gettingstarted/#First-Steps","page":"Getting Started","title":"First Steps","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"We will demonstrate ACME by modeling a simple diode clipper. The first step is to load ACME:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using ACME","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now we create the circuit description:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"circ = @circuit begin\n    j_in = voltagesource()\n    r1 = resistor(1e3)\n    c1 = capacitor(47e-9)\n    d1 = diode(is=1e-15)\n    d2 = diode(is=1.8e-15)\n    j_out = voltageprobe()\n    j_in[+] ⟷ r1[1]\n    j_in[-] ⟷ gnd\n    r1[2] ⟷ c1[1] ⟷ d1[+] ⟷ d2[-] ⟷ j_out[+]\n    gnd ⟷ c1[2] ⟷ d1[-] ⟷ d2[+] ⟷ j_out[-]\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The first six lines inside the begin/end block instantiate circuit elements. Specifying a voltagesource() sets up a voltage source as an input, i.e. the voltage it sources will be specified when running the model. Alternatively, one can instantiate a constant voltage source for say 9V with  voltagesource(9). The resistor and capacitor calls take the resistance in ohm and the capacitance in farad, respectively, as arguments. For the diode, one may specify the saturation current is as done here and/or the emission coefficient η. Finally, desired outputs are denoted by adding probes to the circuit; in this case a voltageprobe() will provide voltage as output.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The remaining four lines specify connections, either among element pins as in j_in[+] ⟷ r1[1], which connects the + pin of the input voltage to pin 1 of the resistor, or among pins and named nets as in j_in[-] ⟷ gnd, which connects the - pin of the input voltage source to a net named gnd. Note that naming nets is only for the sake of readability; there is nothing special about them and the names are arbitrary. As can be seen in the last two lines, multiple pins can be connected at once.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"It is also possible to specify connections following the element definition (separated by commas), in which case the element name may be omitted. However, one can only connect to elements defined before. Thus, above circuit could also be entered as:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"circ = @circuit begin\n    j_in = voltagesource(), [-] ⟷ gnd\n    r1 = resistor(1e3), [1] ⟷ j_in[+]\n    c1 = capacitor(47e-9), [1] ⟷ r1[2], [2] ⟷ gnd\n    d1 = diode(is=1e-15), [+] ⟷ r1[2], [-] ⟷ gnd\n    d2 = diode(is=1.8e-15), [+] ⟷ gnd, [-] ⟷ r1[2]\n    j_out = voltageprobe(), [+] ⟷ r1[2], [-] ⟷ gnd\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now that the circuit has been set up, we need to turn it into a model. This could hardly be any easier:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"model = DiscreteModel(circ, 1/44100)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The second argument specifies the sampling interval, the reciprocal of the sampling rate, here assumed to be the typical 44100 Hz.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Now we can process some input data. It has to be provided as a matrix with one row per input (just one in the example) and one column per sample. So for a sinusoid at 1 kHz lasting one second, we do:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"y = run!(model, sin.(2π*1000/44100*(0:44099)'))\n\n# output\n\n1×44100 Matrix{Float64}:\n 0.0  0.0275964  0.0990996  0.195777  …  -0.537508  -0.462978  -0.36521","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"The output y now likewise is a matrix with one row for the one probe we have added to the circuit and one column per sample.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"More interesting circuits can be found in the examples located at Pkg.dir(\"ACME/examples\").","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"In the likely event that you would like to process real audio data, take a look at the WAV package for reading writing WAV files.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Note that the solver used to solve the non-linear equation when running the model saves solutions to use as starting points in the future. Model execution will therefore become faster after an initial learning phase.  Nevertheless, ACME is at present more geared towards computing all the model matrices than to actually running the model. More complex circuits may run intolerably slow or fail to run altogether.","category":"page"},{"location":"ug/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"ug/#Element-Creation","page":"User Guide","title":"Element Creation","text":"","category":"section"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"All circuit elements are created by calling corresponding functions; see the Element Reference for details.","category":"page"},{"location":"ug/#Circuit-Description","page":"User Guide","title":"Circuit Description","text":"","category":"section"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"Circuits are described using Circuit instances, which are most easily created using the @circuit macro:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"@circuit","category":"page"},{"location":"ug/#ACME.@circuit","page":"User Guide","title":"ACME.@circuit","text":"@circuit begin #= ... =# end\n\nProvides a simple domain-specific language to decribe circuits. The begin/end block can hold element definitions of the form refdes = elementfunc(params) and connection specifications of the form refdes1[pin1] ⟷ refdes2[pin2].\n\nExample\n\nTo create a circuit with a voltage source connected to a resistor:\n\n@circuit begin\n    src = voltagesource(5)\n    r = resistor(1000)\n    src[+] ⟷ r[1]\n    src[-] ⟷ r[2]\nend\n\nAlternatively, connection specifications can be given after an element specification, separated by commas. In that case, the refdes may be omitted, defaulting to the current element.\n\nExample\n\n@circuit begin\n    src = voltagesource(5)\n    r = resistor(1000), src[+] ⟷ [1], src[-] ⟷ [2]\nend\n\nFinally, a connection endpoint may simply be of the form netname, to connect to a named net. (Such named nets are created as needed.)\n\nExample\n\n@circuit begin\n    src = voltagesource(5), [-] ⟷ gnd\n    r = resistor(1000), [1] ⟷ src[+], [2] ⟷ gnd\nend\n\nIf a net or pin specification is not just a single symbol or number, and has to be put in quotes (e.g. \"in+\", \"9V\")\n\nnote: Note\nInstead of ⟷ (\\longleftrightarrow), one can also use ==.\n\n\n\n\n\n","category":"macro"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"The pins provided by each type of element are described in the Element Reference.","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"Instead of or in addition to using the @circuit macro, Circuit instances can also be populated and modified programmatically using the following functions:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"add!\ndelete!\nconnect!\ndisconnect!","category":"page"},{"location":"ug/#ACME.add!","page":"User Guide","title":"ACME.add!","text":"add!(c::Circuit, elem::Element)\n\nAdds the element elem to the circuit c, creating and returning a new, unique reference designator, leaving its pins unconnected.\n\n\n\n\n\nadd!(c::Circuit, designator::Symbol, elem::Element)\n\nAdds the element elem to the circuit c with the reference designator designator, leaving its pins unconnected. If the circuit already contained an element named designator, it is removed first.\n\n\n\n\n\n","category":"function"},{"location":"ug/#Base.delete!","page":"User Guide","title":"Base.delete!","text":"delete!(c::Circuit, designator::Symbol)\n\nDeletes the element named designator from the circuit c (disconnecting all its pins).\n\n\n\n\n\n","category":"function"},{"location":"ug/#ACME.connect!","page":"User Guide","title":"ACME.connect!","text":"connect!(c::Circuit, pins::Union{Symbol,Tuple{Symbol,Any}}...)\n\nConnects the given pins (or named nets) to each other in the circuit c. Named nets are given as Symbols, pins are given as Tuple{Symbols,Any}s, where the first entry is the reference designator of an element in c, and the second entry is the pin name. For convenience, the latter is automatically converted to a Symbol as needed.\n\nExample\n\ncirc = Circuit()\nadd!(circ, :r, resistor(1e3))\nadd!(circ, :src, voltagesource(5))\nconnect!(circ, (:src, -), (:r, 2), :gnd) # connect to gnd net\n\n\n\n\n\n","category":"function"},{"location":"ug/#ACME.disconnect!","page":"User Guide","title":"ACME.disconnect!","text":"disconnect!(c::Circuit, p::Tuple{Symbol,Any})\n\nDisconnects the given pin p from anything else in the circuit c. The pin is given as aTuple{Symbols,Any}, where the first entry is the reference designator of an element in c, and the second entry is the pin name. For convenience, the latter is automatically converted to a Symbol as needed. Note that if e.g. three pin p1, p2, and p3 are connected then disconnect!(c, p1) will disconnect p1 from p2 and p3, but leave p2 and p3 connected to each other.\n\n\n\n\n\n","category":"function"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"For example, a cascade of 20 RC-lowpasses could be generated by:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"circ = @circuit begin\n    src = voltagesource(), [-] ⟷ gnd\n    output = voltageprobe(), [-] ⟷ gnd\nend\npin = (:src, +)\nfor i in 1:20\n    resrefdes = add!(circ, resistor(1000))\n    caprefdes = add!(circ, capacitor(10e-9))\n    connect!(circ, (resrefdes, 1), pin)\n    connect!(circ, (resrefdes, 2), (caprefdes, 1))\n    connect!(circ, (caprefdes, 2), :gnd)\n    global pin = (resrefdes, 2)\nend\nconnect!(circ, pin, (:output, +))","category":"page"},{"location":"ug/#Model-Creation-and-Use","page":"User Guide","title":"Model Creation and Use","text":"","category":"section"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"A Circuit only stores elements and information about their connections. To simulate a circuit, a model has to be derived from it. This can be as simple as:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"model = DiscreteModel(circ, 1/44100)","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"Here, 1/44100 denotes the sampling interval, i.e. the reciprocal of the sampling rate at which the model should run. Optionally, one can specify the solver to use for solving the model's non-linear equation:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"model = DiscreteModel(circ, 1/44100, HomotopySolver{SimpleSolver})","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"See Solvers for more information about the available solvers.","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"Once a model is created, it can be run:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"y = run!(model, u)","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"The input u is matrix with one row for each of the circuit's inputs and one column for each time step to simulate. Likewise, the output y will be a matrix with one row for each of the circuit's outputs and one column for each simulated time step. The order of the rows will correspond to the order in which the respective input and output elements were added to the Circuit. So for above circuit, we may obtain the first 100 samples of the impulse response with","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"run!(model, [1 zeros(1,99)])\n\n# output\n\n1×100 Matrix{Float64}:\n 1.83357e-8  3.1622e-7  2.59861e-6  …  0.00465423  0.00459275  0.00453208","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"To simulate a circuit without inputs, a matrix with zero rows may be passed:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"y = run!(model, zeros(0, 100))","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"The internal state of the model (e.g. capacitor charges) is preserved accross calls to run!.","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"Each invocation of run! in this way has to allocate some memory as temporary storage. To avoid this overhead when running the same model for many small input blocks, a ModelRunner instance can be created explicitly:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"runner = ModelRunner(model, false)\nrun!(runner, y, u)","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"By using a pre-allocated output y as in the example, allocations in run! are reduced to a minimum.","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"Upon creation of a DiscreteModel, its internal states (e.g. capacitor charges) are set to zero. It is also possible to set the states to a steady state (if one can be found) with:","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"steadystate!(model)","category":"page"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"This is often desirable for circuits where bias voltages are only slowly obtained after turning them on.","category":"page"},{"location":"ug/#Solvers","page":"User Guide","title":"Solvers","text":"","category":"section"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"SimpleSolver\nHomotopySolver\nCachingSolver","category":"page"},{"location":"ug/#ACME.SimpleSolver","page":"User Guide","title":"ACME.SimpleSolver","text":"SimpleSolver\n\nThe SimpleSolver is the simplest available solver. It uses Newton iteration which features fast local convergence, but makes no guarantees about global convergence. The initial solution of the iteration is obtained by extrapolating the last solution found (or another solution provided externally) using the available Jacobians. Due to the missing global convergence, the SimpleSolver is rarely useful as such.\n\n\n\n\n\n","category":"type"},{"location":"ug/#ACME.HomotopySolver","page":"User Guide","title":"ACME.HomotopySolver","text":"HomotopySolver{BaseSolver}\n\nThe HomotopySolver extends an existing solver (provided as the type parameter) by applying homotopy to (at least theoretically) ensure global convergence. It can be combined with the SimpleSolver as HomotopySolver{SimpleSolver} to obtain a useful Newton homtopy solver with generally good convergence properties.\n\n\n\n\n\n","category":"type"},{"location":"ug/#ACME.CachingSolver","page":"User Guide","title":"ACME.CachingSolver","text":"CachingSolver{BaseSolver}\n\nThe CachingSolver extends an existing solver (provided as the type parameter) by storing found solutions in a k-d tree to use as initial solutions in the future. Whenever the underlying solver needs more than a preset number of iterations (defaults to five), the solution will be stored. Storing new solutions is a relatively expensive operation, so until the stored solutions suffice to ensure convergence in few iterations throughout, use of a CachingSolver may actually slow things down.\n\nSee M. Holters, U. Zölzer, \"A k-d Tree Based Solution Cache for the Non-linear Equation of Circuit Simulations\" for a more detailed discussion.\n\n\n\n\n\n","category":"type"},{"location":"ug/","page":"User Guide","title":"User Guide","text":"The default solver used is a HomotopySolver{CachingSolver{SimpleSolver}}.","category":"page"},{"location":"elements/#Element-Reference","page":"Element Reference","title":"Element Reference","text":"","category":"section"},{"location":"elements/#Passives","page":"Element Reference","title":"Passives","text":"","category":"section"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"resistor\ncapacitor\ninductor(l)\ninductor(::Type{Val{:JA}})\ntransformer(l1, l2; coupling_coefficient=1,mutual_coupling=coupling_coefficient*sqrt(l1*l2))\ntransformer(::Type{Val{:JA}})","category":"page"},{"location":"elements/#ACME.resistor","page":"Element Reference","title":"ACME.resistor","text":"resistor(r)\n\nCreates a resistor obeying Ohm’s law. The resistance r has to be given in Ohm.\n\nPins: 1, 2\n\n\n\n\n\n","category":"function"},{"location":"elements/#ACME.capacitor","page":"Element Reference","title":"ACME.capacitor","text":"capacitor(c)\n\nCreates a capacitor. The capacitance c has to be given in Farad.\n\nPins: 1, 2\n\n\n\n\n\n","category":"function"},{"location":"elements/#ACME.inductor-Tuple{Any}","page":"Element Reference","title":"ACME.inductor","text":"inductor(l)\n\nCreates an inductor. The inductance l has to be given in Henri.\n\nPins: 1, 2\n\n\n\n\n\n","category":"method"},{"location":"elements/#ACME.inductor-Tuple{Type{Val{:JA}}}","page":"Element Reference","title":"ACME.inductor","text":"inductor(Val{:JA}; D, A, n, a, α, c, k, Ms)\n\nCreates a non-linear inductor based on the Jiles-Atherton model of magnetization assuming a toroidal core thin compared to its diameter. The parameters are set using named arguments:\n\nparameter description\nD Torus diameter (in meters)\nA Torus cross-sectional area (in square-meters)\nn Winding's number of turns\na Shape parameter of the anhysteretic magnetization curve (in Ampere-per-meter)\nα Inter-domain coupling\nc Ratio of the initial normal to the initial anhysteretic differential susceptibility\nk amount of hysteresis (in Ampere-per-meter)\nMs saturation magnetization (in Ampere-per-meter)\n\nA detailed discussion of the parameters can be found in D. C. Jiles and D. L. Atherton, “Theory of ferromagnetic hysteresis,” J. Magn. Magn. Mater., vol. 61, no. 1–2, pp. 48–60, Sep. 1986 and J. H. B. Deane, “Modeling the dynamics of nonlinear inductor circuits,” IEEE Trans. Magn., vol. 30, no. 5, pp. 2795–2801, 1994, where the definition of c is taken from the latter. The ACME implementation is discussed in M. Holters, U. Zölzer, \"Circuit Simulation with Inductors and Transformers Based on the Jiles-Atherton Model of Magnetization\".\n\nPins: 1, 2\n\n\n\n\n\n","category":"method"},{"location":"elements/#ACME.transformer-Tuple{Any, Any}","page":"Element Reference","title":"ACME.transformer","text":"transformer(l1, l2; coupling_coefficient=1, mutual_coupling=coupling_coefficient*sqrt(l1*l2))\n\nCreates a transformer with two windings having inductances. The primary self-inductance l1 and the secondary self-inductance l2 have to be given in Henri. The coupling can either be specified using coupling_coefficient (0 is not coupled, 1 is closely coupled) or by mutual_coupling, the mutual inductance in Henri, where the latter takes precedence if both are given.\n\nPins: primary1 and primary2 for primary winding, secondary1 and secondary2 for secondary winding\n\n\n\n\n\n","category":"method"},{"location":"elements/#ACME.transformer-Tuple{Type{Val{:JA}}}","page":"Element Reference","title":"ACME.transformer","text":"transformer(Val{:JA}; D, A, ns, a, α, c, k, Ms)\n\nCreates a non-linear transformer based on the Jiles-Atherton model of magnetization assuming a toroidal core thin compared to its diameter. The parameters are set using named arguments:\n\nparameter description\nD Torus diameter (in meters)\nA Torus cross-sectional area (in square-meters)\nns Windings' number of turns as a vector with one entry per winding\na Shape parameter of the anhysteretic magnetization curve (in Ampere-per-meter)\nα Inter-domain coupling\nc Ratio of the initial normal to the initial anhysteretic differential susceptibility\nk amount of hysteresis (in Ampere-per-meter)\nMs saturation magnetization (in Ampere-per-meter)\n\nA detailed discussion of the parameters can be found in D. C. Jiles and D. L. Atherton, “Theory of ferromagnetic hysteresis,” J. Magn. Magn. Mater., vol. 61, no. 1–2, pp. 48–60, Sep. 1986 and J. H. B. Deane, “Modeling the dynamics of nonlinear inductor circuits,” IEEE Trans. Magn., vol. 30, no. 5, pp. 2795–2801, 1994, where the definition of c is taken from the latter. The ACME implementation is discussed in M. Holters, U. Zölzer, \"Circuit Simulation with Inductors and Transformers Based on the Jiles-Atherton Model of Magnetization\".\n\nPins: 1 and 2 for primary winding, 3 and 4 for secondary winding, and so on\n\n\n\n\n\n","category":"method"},{"location":"elements/#Independent-Sources","page":"Element Reference","title":"Independent Sources","text":"","category":"section"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"voltagesource\ncurrentsource","category":"page"},{"location":"elements/#ACME.voltagesource","page":"Element Reference","title":"ACME.voltagesource","text":"voltagesource(; rs=0)\nvoltagesource(v; rs=0)\n\nCreates a voltage source. The source voltage v has to be given in Volt. If omitted, the source voltage will be an input of the circuit. Optionally, an internal series resistance rs (in Ohm) can be given which defaults to zero.\n\nPins: + and - with v being measured from + to -\n\n\n\n\n\n","category":"function"},{"location":"elements/#ACME.currentsource","page":"Element Reference","title":"ACME.currentsource","text":"currentsource(; gp=0)\ncurrentsource(i; gp=0)\n\nCreates a current source. The source current i has to be given in Ampere. If omitted, the source current will be an input of the circuit. Optionally, an internal parallel conductance gp (in Ohm⁻¹) can be given which defaults to zero.\n\nPins: + and - where i measures the current leaving source at the + pin\n\n\n\n\n\n","category":"function"},{"location":"elements/#Probes","page":"Element Reference","title":"Probes","text":"","category":"section"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"voltageprobe\ncurrentprobe","category":"page"},{"location":"elements/#ACME.voltageprobe","page":"Element Reference","title":"ACME.voltageprobe","text":"voltageprobe()\n\nCreates a voltage probe, providing the measured voltage as a circuit output. Optionally, an internal parallel conductance gp (in Ohm⁻¹) can be given which defaults to zero.\n\nPins: + and - with the output voltage being measured from + to -\n\n\n\n\n\n","category":"function"},{"location":"elements/#ACME.currentprobe","page":"Element Reference","title":"ACME.currentprobe","text":"currentprobe()\n\nCreates a current probe, providing the measured current as a circuit output. Optionally, an internal series resistance rs (in Ohm) can be given which defaults to zero.\n\nPins: + and - with the output current being the current entering the probe at +\n\n\n\n\n\n","category":"function"},{"location":"elements/#Semiconductors","page":"Element Reference","title":"Semiconductors","text":"","category":"section"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"diode\nbjt\nmosfet","category":"page"},{"location":"elements/#ACME.diode","page":"Element Reference","title":"ACME.diode","text":"diode(;is=1e-12, η = 1)\n\nCreates a diode obeying Shockley's law i=I_Scdot(e^v(eta v_T)-1) where v_T is fixed at 25 mV. The reverse saturation current is has to be given in Ampere, the emission coefficient η is unitless.\n\nPins: + (anode) and - (cathode)\n\n\n\n\n\n","category":"function"},{"location":"elements/#ACME.bjt","page":"Element Reference","title":"ACME.bjt","text":"bjt(typ; is=1e-12, η=1, isc=is, ise=is, ηc=η, ηe=η, βf=1000, βr=10,\n    ile=0, ilc=0, ηcl=ηc, ηel=ηe, vaf=Inf, var=Inf, ikf=Inf, ikr=Inf)\n\nCreates a bipolar junction transistor obeying the Gummel-Poon model\n\ni_f = fracbeta_f1+beta_f I_SE cdot (e^v_E(eta_E v_T)-1)\n\ni_r = fracbeta_r1+beta_r I_SC cdot (e^v_C(eta_C v_T)-1)\n\ni_cc = frac2(1-fracV_EV_ar-fracV_CV_af)\n               1+sqrt1+4(fraci_fI_KF+fraci_rI_KR)\n          (i_f - i_r)\n\ni_BE = frac1beta_f i_f + I_LE cdot (e^v_E(eta_EL v_T)-1)\n\ni_BC = frac1beta_r i_r + I_LC cdot (e^v_C(eta_CL v_T)-1)\n\ni_E = i_cc + i_BE qquad i_C=-i_cc + i_BC\n\nwhere v_T is fixed at 25 mV. For\n\nI_LE=I_LC=0quad V_ar=V_af=I_KF=I_KR=\n\nthis reduces to the Ebers-Moll equation\n\ni_E = I_SE cdot (e^v_E(eta_E v_T)-1)\n           - fracbeta_r1+beta_r I_SC cdot (e^v_C(eta_C v_T)-1)\n\ni_C = -fracbeta_f1+beta_f I_SE cdot (e^v_E(eta_E v_T)-1)\n           + I_SC cdot (e^v_C(eta_C v_T)-1)\n\nAdditionally, terminal series resistances are supported.\n\nThe parameters are set using named arguments:\n\nparameter description\ntyp Either :npn or :pnp, depending on desired transistor type\nis Reverse saturation current in Ampere\nη Emission coefficient\nisc Collector reverse saturation current in Ampere (overriding is)\nise Emitter reverse saturation current in Ampere (overriding is)\nηc Collector emission coefficient (overriding η)\nηe Emitter emission coefficient (overriding η)\nβf Forward current gain\nβr Reverse current gain\nilc Base-collector junction leakage current in Ampere\nile Base-emitter junction leakage current in Ampere\nηcl Base-collector junction leakage emission coefficient (overriding η)\nηel Base-emitter junction leakage emission coefficient (overriding η)\nvaf Forward Early voltage in Volt\nvar Reverse Early voltage in Volt\nikf Forward knee current (gain roll-off) in Ampere\nikr Reverse knee current (gain roll-off) in Ampere\nre Emitter terminal resistance\nrc Collector terminal resistance\nrb Base terminal resistance\n\nPins: base, emitter, collector\n\n\n\n\n\n","category":"function"},{"location":"elements/#ACME.mosfet","page":"Element Reference","title":"ACME.mosfet","text":"mosfet(typ; vt=0.7, α=2e-5, λ=0)\n\nCreates a MOSFET transistor with the simple model\n\ni_D=begincases\n  0  textif  v_GS le v_T \n  alpha cdot (v_GS - v_T - tfrac12v_DS)cdot v_DS\n  cdot (1 + lambda v_DS)\n   textif  v_DS le v_GS - v_T cap v_GS  v_T \n  fracalpha2 cdot (v_GS - v_T)^2 cdot (1 + lambda v_DS)\n   textotherwise\nendcases\n\nThe typ parameter chooses between NMOS (:n) and PMOS (:p). The threshold voltage vt is given in Volt, α (in A/V²) is a constant depending on the physics and dimensions of the device, and λ (in V⁻¹) controls the channel length modulation.\n\nOptionally, it is possible to specify tuples of coefficients for vt and α. These will be used as polynomials in v_GS to determine v_T and alpha, respectively. E.g. with vt=(0.7, 0.1, 0.02), the v_GS-dpendent threshold voltage v_T = 07 + 01cdot v_GS + 002cdot v_GS^2 will be used.\n\nPins: gate, source, drain\n\n\n\n\n\n","category":"function"},{"location":"elements/#Integrated-Circuits","page":"Element Reference","title":"Integrated Circuits","text":"","category":"section"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"opamp()\nopamp(::Type{Val{:macak}}, gain, vomin, vomax)","category":"page"},{"location":"elements/#ACME.opamp-Tuple{}","page":"Element Reference","title":"ACME.opamp","text":"opamp(;maxgain=Inf, gain_bw_prod=Inf)\n\nCreates a linear operational amplifier as a voltage-controlled voltage source. The input current is zero while the input voltage is mapped to the output voltage according to the transfer function\n\nH(f) = fracA_textmaxsqrtA_textmax^2-1 i fracff_textUG + 1\n\nwhere f is the signal frequency, A_textmax (maxgain) is the maximum open loop gain and f_textUG (gain_bw_prod) is the gain/bandwidth product (unity gain bandwidth). For gain_bw_prod=Inf (the default), this corresponds to a frequency-independent gain of maxgain. For maxgain=Inf (the default), the amplifier behaves as a perfect integrator.\n\nFor both maxgain=Inf and gain_bw_prod=Inf, i.e. just opamp(), an ideal operational amplifier is obtained that enforces the voltage between the input pins to be zero while sourcing arbitrary current on the output pins without restricting their voltage.\n\nNote that the opamp has two output pins, where the negative one will typically be connected to a ground node and has to provide the current sourced on the positive one.\n\nPins: in+ and in- for input, out+ and out- for output\n\n\n\n\n\n","category":"method"},{"location":"elements/#ACME.opamp-Tuple{Type{Val{:macak}}, Any, Any, Any}","page":"Element Reference","title":"ACME.opamp","text":"opamp(Val{:macak}, gain, vomin, vomax)\n\nCreates a clipping operational amplifier where input and output voltage are related by\n\nv_textout = frac12cdot(v_textmax+v_textmin)\n                   +frac12cdot(v_textmax-v_textmin)cdot\n                    tanhleft(fracgfrac12cdot(v_textmax-v_textmin)cdot  v_textinright)\n\nThe input current is zero, the output current is arbitrary.\n\nNote that the opamp has two output pins, one of which will typically be connected to a ground node and has to provide the current sourced on the other output pin.\n\nPins: in+ and in- for input, out+ and out- for output\n\n\n\n\n\n","category":"method"},{"location":"elements/#Adding-custom-elements","page":"Element Reference","title":"Adding custom elements","text":"","category":"section"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"One advantage of ACME is that it is relatively easy to define one's own circuit elements. However, the required formalism is a bit non-obvious. So this section is meant to be an introduction into steps required to implement a custom circuit element. As a running example, we shall consider an operational transconductance amplifier (OTA). As the name suggests, it is similar to an operation amplifier in that it has two input pins, acting as a differential input, and a single output pin. For the OTA, the output current is (approximately) proportional to the differential input voltage. The factor of proportionality (transconductance) can be controlled by the current drawn at a further pin. Additionally, the OTA has power supply pins, of course.","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"We shall start with a simple linear model with fixed transconductance. We idealize the input current to be zero adn the output voltage as arbitrary, i.e. the OTA acts as an ideal, voltage-controlled current source. The first step is to define the ports (pairs of pins) of the element, such that the behavior of the element can be defined in terms of the voltages across and currents through these ports. For the OTA, the first port can obviously be chosen as the input pins. For the second port, the output pin has to be paired with a pin that provides the current to be sourced at the output to maintain a net current sum of zero. As for the opamp models, we therefore introduce a negative output pin. Each port is associated with a voltage and a current as depicted in the following diagram:","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"(Image: )","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"The OTA is thus described with i_2=-gcdot v_1 (where g is the transconductance) and i_1=0. The negative sign in the first equation is required because we want a positive input voltage to yield a positive output current pointing out of the OTA, i.e. opposite to i_2.","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"ACME uses a matrix notation that in full generality looks like","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"bmM_textvbmv + bmM_textibmi + bmM_textxbmx\n+ bmM_dottextxdotbmx + bmM_textqbmq\n= bmM_textubmu + bmu_0","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"The matrices bmM_cdot describe the element and will have to be determined in the following. The port voltages and currents are collected in vectors bmv and bmi, respectively. The vector bmx holds the internal states of the element and dotbmx their derivatives. We model a stateless OTA, so these parts can be ignored by choosing bmM_textx and bmM_dottextx as zero-column matrices. The vector bmq becomes relevant for nonlinear elements, but can likewise be ignored for the moment choosing bmM_textq as a zero-column matrix. The vector bmu contains externally controlled inputs, which we don't have for the OTA, so bmM_textu is also chosen to have zero columns. Finally, bmu_0 is again used for describing the element. For the linear OTA, we can write the two equations as","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"underbracebeginpmatrix g  0  0  0 endpmatrix_bmM_textv\ncdotunderbracebeginpmatrix v_1  v_2 endpmatrix_bmv\n+\nunderbracebeginpmatrix 0  1  1  0 endpmatrix_bmM_texti\ncdotunderbracebeginpmatrix i_1  i_2 endpmatrix_bmi\n=\nunderbracebeginpmatrix 0  0 endpmatrix_bmu_0","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"where the first row translates to i_2=-gcdot v_1 and the second row to i_1=0. Thus, we obtain","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"bmM_textv=beginpmatrix g  0  0  0 endpmatrix\nquad bmM_texti = beginpmatrix 0  1  1  0 endpmatrix\nquad bmu_0 = beginpmatrix 0  0 endpmatrix","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"Translation to ACME is straight-forward, as the Element constructor takes self-explanatorily named keyword arguments:","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"g=10e-3\nACME.Element(mv=[g 0; 0 0], mi=[0 1; 1 0],  ports=[\"in+\" => \"in-\", \"out+\" => \"out-\"])","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"Omitted matrices are taken to be empty/all-zero matrices of suitable size. The ports are specified as pairs of pins. The names can be chosen arbitrarily. If the same pin name is used in multiple ports, these ports share a pin. For example, the bjt has a base-collector and a base-emitter port, sharing base as a common pin.","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"It is usually convenient to wrap the element creation in a suitable function like it is done for the elements defined as part of ACME:","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"ota(g) = ACME.Element(mv=[g 0; 0 0], mi=[0 1; 1 0],  ports=[\"in+\" => \"in-\", \"out+\" => \"out-\"])","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"A simple test circuit for this OTA could then be run with","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"circ = @circuit begin\n    Jin = voltagesource()\n    U = ota(10e-3), [\"in+\"] ⟷ Jin[+], [\"in-\"] ⟷ Jin[-]\n    Jout = currentprobe(), [+] ⟷ U[\"out+\"], [-] ⟷ U[\"out-\"]\nend\nmodel = DiscreteModel(circ, 1/44100)\nrun!(model, [-2.0 -1.0 0.0 1.0 2.0])\n\n# output\n\n1×5 Matrix{Float64}:\n -0.02  -0.01  0.0  0.01  0.02","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"Real OTAs exhibit nonlinear behavior. A full treatment of the all the sources of nonlinearities is beyond this manual, but a first refinement is given by the input/output relationship i_2=-i_textbiascdottanh(v_1(2v_textT)), where v_textT is the thermal voltage (approximately 25 mV at room temperature) and the transconductance is controlled with the bias current i_textbias by g=i_textbias(2v_textT) for small input voltages. For higher input voltages, saturation occurs and the output current cannot exceed the bias current.","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"To encode nonlinear behavior with ACME, all quantities that participate in the nonlinearity have to be collected in the bmq vector, i.e. we now need a non-empty matrix bmM_textq, and the nonlinear equation has be provided via a function bmf such that bmf(bmq)=bm0 is the desired condition. For the present example, we choose q_1=v_1 and q_2=i_2 with","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"beginpmatrix 1  0  0  0  0  0 endpmatrixbmv\n+ beginpmatrix 0  0  0  1  1  0 endpmatrixbmi\n+ beginpmatrix -1  0  0  -1  0  0 endpmatrixbmq\n= beginpmatrix 0  0  0 endpmatrix","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"i.e.","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"bmM_textv=beginpmatrix 1  0  0  0  0  0 endpmatrix\nquad bmM_texti = beginpmatrix 0  0  0  1  1  0 endpmatrix\nquad bmM_textq=beginpmatrix -1  0  0  -1  0  0 endpmatrix\nquad bmu_0 = beginpmatrix 0  0  0 endpmatrix","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"and","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"bmf(bmq) = beginpmatrix i_textbiascdottanh(q_1(2v_textT)) + q_2 endpmatrix","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"Note that, compared to the linear case, this adds two equations, a linear one and a nonlinear one, matching the two additional unknowns (q_1 and q_2).","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"In order to do nonlinear equation solving, ACME requires not only the function bmf, but also its Jacobian, in this case","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"bmJ(bmq) = beginpmatrix fracdf_1dq_1  fracdf_1dq_2 endpmatrix\n= beginpmatrix fraci_textbias2v_textTcdotcosh^2(q_1(2v_textT))  1 endpmatrix","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"The final bit of information is that the function value (residual) and the value of the Jacobian have to returned as an @SVector and @SMatrix (from the StaticArrays package), respectively, combined in a tuple. Thus, the implementation becomes:","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"using ACME, StaticArrays # hide\nota(i_bias) = ACME.Element(\n    mv=[1 0; 0 0; 0 0], mi=[0 0; 0 1; 1 0], mq=[-1 0; 0 -1; 0 0],\n    ports=[\"in+\" => \"in-\", \"out+\" => \"out-\"],\n    nonlinear_eq = function (q)\n        res = @SVector [i_bias * tanh(q[1]/50e-3) + q[2]]\n        J = @SMatrix [i_bias / (50e-3*coth(q[1]/50e-3)^2) 1]\n        return (res, J)\n    end\n)\nnothing # hide","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"With the same test circuit as before, we can create a plot of the input/output relationship:","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"circ = @circuit begin\n    Jin = voltagesource()\n    U = ota(10e-3), [\"in+\"] ⟷ Jin[+], [\"in-\"] ⟷ Jin[-]\n    Jout = currentprobe(), [+] ⟷ U[\"out+\"], [-] ⟷ U[\"out-\"]\nend\nmodel = DiscreteModel(circ, 1/44100)\nu = range(-0.2, 0.2, length=200)\ny = run!(model, u')'\nusing Plots\nplot(u, y; xlabel=\"input voltage\", ylabel=\"output current\", legend=false)","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"For the small input voltages, the theoretical transconductance of 10 mA / 50 mV = 0.2 Ω⁻¹ is obtained, while for the larger voltages, the saturation effect becomes clearly visible.","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"As the nonlinear function bmf may be evaluated very often, it is worth optimizing it a fair bit. In particular, we may note that 1coth^2(x)=1-tanh^2(x) to save on the number of typically expensive evaluations of hyperbolic functions. Furthermore, we can redefine q_1=v_1(2v_textT) by using","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"quad bmM_textq=beginpmatrix -2v_textT  0  0  -1  0  0 endpmatrix","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"for another, very minor simplification of the nonlinear function. This leads to the functionally equivalent:","category":"page"},{"location":"elements/","page":"Element Reference","title":"Element Reference","text":"using ACME, StaticArrays # hide\nota(i_bias) = ACME.Element(\n    mv=[1 0; 0 0; 0 0], mi=[0 0; 0 1; 1 0], mq=[-50e-3 0; 0 -1; 0 0],\n    ports=[\"in+\" => \"in-\", \"out+\" => \"out-\"],\n    nonlinear_eq = function (q)\n        th = tanh(q[1])\n        res = @SVector [i_bias*th + q[2]]\n        J = @SMatrix [i_bias*(1-th^2) 1.0]\n        return (res, J)\n    end\n)\nnothing # hide","category":"page"},{"location":"#ACME.jl-Analog-Circuit-Modeling-and-Emulation-for-Julia","page":"Home","title":"ACME.jl - Analog Circuit Modeling and Emulation for Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ACME is a Julia package for the simulation of electrical circuits, focusing on audio effect circuits. It allows to programmatically describe a circuit in terms of elements and connections between them and then automatically derive a model for the circuit. The model can then be run on varying input data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ACME is based on the method described in M. Holters, U. Zölzer, \"A Generalized Method for the Derivation of Non-Linear State-Space Models from Circuit Schematics\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n      \"gettingstarted.md\",\n      \"ug.md\",\n      \"elements.md\",\n  ]","category":"page"}]
}
